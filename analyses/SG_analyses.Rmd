---
title: "SG_analyses"
author: "Sabrina Grant"
date: "`r Sys.Date()`"
output: html_document
---

#packages
```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# packages
install.packages("librarian")
librarian::shelf("tidyverse", "vegan", "ggplot2", "dplyr", "car", "ggpubr", "minpack.lm", "googledrive", "janitor", "nlme", "RColorBrewer", "splitstackshape", "lubridate", "matrixStats", "readr", "stringr", "broom")

library(googledrive)

```
#loading data
```{r}

# load data
drive_deauth()

drive_auth(scopes = "https://www.googleapis.com/auth/drive")

file <- drive_find("kelp_recovery_data.rda",
                   shared_drive = "MBA_kelp_recovery_research")
file

drive_download(
  as_id(file$id),
  path = "kelp_recovery_data.rda",
  overwrite = TRUE
)

load("kelp_recovery_data.rda")
ls()
```


#Fixing up data frames
```{r}
###averaging counts and % cover per transect

# Helper function to get the most common value (mode)
get_mode <- function(x) {
  ux <- na.omit(unique(x))
  ux[which.max(tabulate(match(x, ux)))]
}

quad_transect_avgs <- quad_data %>%
  group_by(site, site_type, zone, survey_date, transect) %>%
  summarise(
    across(where(is.numeric) & !any_of("quadrat"), ~ mean(.x, na.rm = TRUE)),
    substrate = get_mode(substrate),
    .groups = "drop"
  )


# View result
print(quad_transect_avgs)

#now averaging per survey 
quad_avgs <- quad_transect_avgs %>%
  group_by(site, site_type, zone, survey_date) %>%
  summarise( 
    across(where(is.numeric) & !any_of("transect"), ~mean(.x, na.rm = TRUE)), 
    substrate = get_mode(substrate), 
    .groups = "drop")

# View result
print(quad_avgs)

#now making a new column to represent urchin behavior i.e. how many urchins are actively grazing 

quad_avgs1 <- quad_avgs %>%
  mutate( purple_urchin_active_foraging_densitym2 = purple_urchin_densitym2 - purple_urchin_conceiledm2,
    red_urchin_active_foraging_densitym2 = red_urchin_densitym2 - red_urchin_conceiledm2
  ) %>%
  mutate(total_urchin_densitym2 = purple_urchin_densitym2 + red_urchin_densitym2, 
         total_urchin_foraging_densitym2 = purple_urchin_active_foraging_densitym2 + red_urchin_active_foraging_densitym2)
  #separate purps and reds, start with just purps

#averaging transects
kelp_avgs <- kelp_data %>%
  group_by(site, site_type, zone, survey_date) %>%
  summarise( 
    across(where(is.numeric) & !any_of("transect"), ~mean(.x, na.rm = TRUE)), 
    .groups = "drop") 

macro_avgs <- macro_data %>%
  group_by(site, site_type, zone, survey_date) %>%
  summarise( 
    across(where(is.numeric) & !any_of("transect"), ~mean(.x, na.rm = TRUE)), 
    .groups = "drop")


```



#Merging Quad/Kelp/Macro Dfs

```{r}
merged_data <- kelp_avgs %>%
  mutate(site = if_else(site == "RECO_04", "REC_04", site)) %>%
  left_join(quad_avgs1, by = c("site", "site_type", "zone", "survey_date")) %>%
  left_join(macro_avgs, by = c("site","site_type", "zone", "survey_date"))

#creating a new column that just has years for future analysis  
merged_data$year <- as.numeric(format(merged_data$survey_date, "%Y"))
  

view(merged_data)
```

#2024 data 
```{r}
#normalizing 2024 data 

year_one_data <- merged_data %>% 
  filter(year == 2024) %>%
  filter() %>%
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2.x, everything())

year_one_data[sapply(year_one_data, is.numeric)] <-
  lapply(year_one_data[sapply(year_one_data, is.numeric)],
         function(x) { x[is.na(x)] <- 0; x })

year_one_data %>%
  group_by(site, site_type, zone, year) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "drop")
  
```


##LDA at the depth zone level
```{r}
library(MASS)

year_one_data$site_type <- as.factor(year_one_data$site_type)
  
# Identify columns that contain "20m2"
cols_to_scale <- grep("20m2", names(year_one_data), value = TRUE)

# Divide those columns by 20
year_one_data[cols_to_scale] <- lapply(year_one_data[cols_to_scale], function(x) x / 20)

# 3. Rename those columns by removing "20m2_"
names(year_one_data)[names(year_one_data) %in% cols_to_scale] <-
  gsub("20m2","", cols_to_scale)

lda_model <- lda(site_type ~ macro_stipe_density_.x + density_ptecal + density_nerlue + density_lamset + density_eisarb + purple_urchin_densitym2 + purple_urchin_conceiledm2 + lamr_densitym2 + macr_densitym2 + macj_densitym2 + nerj_densitym2 + ptej_densitym2 + lsetj_densitym2  + cov_articulated_coralline + cov_crustose_coralline + cov_encrusting_red + cov_fleshy_red + cov_stephanocystis + cov_dictyoneurum_spp  + cov_desmarestia_spp + cov_lam_holdfast_live + cov_mac_holdfast_live + cov_bare_rock + cov_bare_sand + cov_shell_debris, data = year_one_data)


#lda figure
plot(lda_model)

#lda summary
lda_model

#getting predictions etc etc 
pred <- predict(lda_model)

pred_class <- pred$class

#ACCURACY = 85.42
library(caret)
confusionMatrix(pred_class, year_one_data$site_type)

results <- year_one_data %>%
  mutate(predicted = pred_class, 
         match = site_type == predicted)

#seeing mismatches 
results <- results %>%
  dplyr::select(year, site, zone, site_type, predicted, match, everything())

mismatches <- results %>% filter(!match)

mismatches

results 


```


###coefficients of LDA
```{r}
library(tidyr)

# Get coefficients into tidy format
coef_df <- as.data.frame(lda_model$scaling)
coef_df$variable <- rownames(coef_df)
coef_long <- pivot_longer(coef_df, cols = c(LD1, LD2), names_to = "LD", values_to = "coefficient")

# Plot
ggplot(coef_long, aes(x = reorder(variable, coefficient), y = coefficient, fill = LD)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  theme_minimal(base_size = 14) +
  labs(
    title = "LDA Coefficients by Discriminant Function",
    x = "Variable",
    y = "Coefficient"
  ) +
  scale_fill_brewer(palette = "Set1")

```

#FIG 1: LDA of 2024 Patch Discrimination
```{r}
library(ggplot2)
library(dplyr)
library(MASS)
library(grid)  # for arrows

# Get LDA scores 

lda_scores <- as.data.frame(predict(lda_model)$x) 
lda_scores$site_type <- year_one_data$site_type 

# Plot LD1 vs LD2 

ggplot(lda_scores, aes(x = LD1, y = LD2, color = site_type, shape = site_type)) + geom_point(size = 3.5, alpha = 0.9) + 
  stat_ellipse(level = 0.95, size = 1, alpha = 0.6) + 
  scale_color_brewer(palette = "Set1") + 
  theme_minimal(base_size = 16) + 
  labs( title = "Linear Discriminant Analysis", subtitle = "95% confidence ellipses by site type", x = paste0("LD1 (", round(lda_model$svd[1]^2 / sum(lda_model$svd^2) * 100, 1), "%)"), y = paste0("LD2 (", round(lda_model$svd[2]^2 / sum(lda_model$svd^2) * 100, 1), "%)"), color = "Site Type", shape = "Site Type" ) + 
  theme( plot.title = element_text(face = "bold", size = 20, hjust = 0.5, margin = margin(b = 10)), plot.subtitle = element_text(size = 14, hjust = 0.5, margin = margin(b = 15)), axis.title = element_text(face = "bold", size = 15), axis.text = element_text(size = 13), legend.title = element_text(face = "bold", size = 14), legend.text = element_text(size = 12), panel.grid.minor = element_blank(), panel.grid.major = element_line(color = "grey85", linewidth = 0.3) )


```



##2025 data
##creating new df
```{r}
#filtering to just select for 2025 data 
year_two_data <- merged_data %>% 
  filter(year == 2025) %>%
  filter() %>%
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2.x, everything())

  
# Identify columns that contain "20m2"
cols_to_scale <- grep("20m2", names(year_two_data), value = TRUE)

# Divide those columns by 20
year_two_data[cols_to_scale] <- lapply(year_two_data[cols_to_scale], function(x) x / 20)

# 3. Rename those columns by removing "20m2_"
names(year_two_data)[names(year_two_data) %in% cols_to_scale] <-
  gsub("20m2","", cols_to_scale)


year_two_data[sapply(year_two_data, is.numeric)] <-
  lapply(year_two_data[sapply(year_two_data, is.numeric)],
         function(x) { x[is.na(x)] <- 0; x })

year_two_data %>%
  group_by(site, site_type, zone, year) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "drop")
  

print(year_two_data)
```

##using 2024 LDA to predict 2025
```{r}

library(MASS)
library(dplyr)

#predicting 2025 patch types based on model
pred_2025 <- predict(lda_model, newdata = year_two_data)

year_two_data <- year_two_data %>%
  dplyr::mutate(site_type_pred = pred_2025$class) %>%
  dplyr::select(year, site, zone, site_type, site_type_pred, dplyr::everything())


#setting up the 2024 df with the predictions column 
pred_2024 <- predict(lda_model, newdata = year_one_data)
year_one_data$site_type_pred <- pred_2024$class

year_one_data <- year_one_data %>%
  dplyr::mutate(site_type_pred = pred_2024$class) %>%
  dplyr::select(year, site, zone, site_type, site_type_pred, dplyr::everything())


##REJOINING 2024 AND 2025 DFS

# Rename the column first
year_one_renamed <- year_one_data %>%
  dplyr::rename(site_type_pred_2024 = site_type_pred) %>%
  dplyr::select(site, zone, site_type, site_type_pred_2024)

year_two_renamed <- year_two_data %>%
  dplyr::rename(site_type_pred_2025 = site_type_pred) %>%
  dplyr::select(site, zone, site_type, site_type_pred_2025)

#merge
merged <- dplyr::left_join(year_one_renamed, year_two_renamed, by = c("site", "zone", "site_type"))


#cross-tabulate 2024 predictions with 2025
library(dplyr)

merged <- year_one_data %>%
  dplyr::select(site, zone, site_type, site_type_pred_2024 = site_type_pred) %>%
  left_join(
    year_two_data %>%
      dplyr::select(site, zone, site_type, site_type_pred_2025 = site_type_pred),
    by = c("site", "zone", "site_type")
  )

view(merged)
cross_tab <- table(merged$site_type_pred_2024, merged$site_type_pred_2025)

cross_tab
```

#FIG 2: Heatmap of Predicted Patch Transitions
```{r}
library(ggplot2)
library(reshape2)
library(viridis)

# Melt the table
cross_tab_melt <- reshape2::melt(cross_tab)

# changing the order of the variables for my plot
desired_order_2024 <- c("BAR", "INCIP", "FOR") 
desired_order_2025 <- c("BAR", "INCIP", "FOR")  

# Convert to factors with specified levels
cross_tab_melt$Var1 <- factor(cross_tab_melt$Var1, levels = desired_order_2024)
cross_tab_melt$Var2 <- factor(cross_tab_melt$Var2, levels = desired_order_2025)

my_colors <- rev(brewer.pal(11, "RdYlBu"))

# Sleek publication-ready heatmap
ggplot(cross_tab_melt, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "grey90", linewidth = 0.3) +
  geom_text(aes(label = value), 
            color = ifelse(cross_tab_melt$value > max(cross_tab_melt$value)/2, "white", "black"), 
            size = 5, fontface = "bold") +
 scale_fill_gradientn(colors = my_colors) +
  labs(
    x = "2024 Predicted Patch Type",
    y = "2025 Predicted Patch Type",
    title = "Transition of Predicted Patch Types from 2024 to 2025",
    fill = "Count"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 13),
    axis.text.y = element_text(face = "bold", size = 13),
    axis.title = element_text(face = "bold", size = 14),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 18, margin = margin(b = 10)),
    legend.title = element_text(face = "bold", size = 13),
    legend.text = element_text(size = 12),
    panel.grid = element_blank()
  )


```

```{r}
library(dplyr)
library(reshape2)
library(ggplot2)
library(viridis)

# Make sure your data has site_type_pred_2024, site_type_pred_2025, and zone
# Create a summarized table per zone
cross_tab_zone <- merged %>%
  dplyr::group_by(zone, site_type_pred_2024, site_type_pred_2025) %>%
  dplyr::summarise(count = n(), .groups = "drop")

# Plot faceted heatmap
ggplot(cross_tab_zone, aes(x = site_type_pred_2024, y = site_type_pred_2025, fill = count)) +
  geom_tile(color = "grey90", size = 0.3) +
  geom_text(aes(label = count),
            color = ifelse(cross_tab_zone$count > max(cross_tab_zone$count)/2, "white", "black"),
            size = 4, fontface = "bold") +
  scale_fill_viridis(option = "C", direction = -1, name = "Count") +
  labs(
    x = "Predicted 2024 Patch Type",
    y = "Predicted 2025 Patch Type",
    title = "Transition of Predicted Patch Types by Zone"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 12),
    axis.text.y = element_text(face = "bold", size = 12),
    axis.title = element_text(face = "bold", size = 13),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16, margin = margin(b = 10)),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(size = 11),
    panel.grid = element_blank()
  ) +
  facet_wrap(~ zone, scales = "free")  # facets by zone

```

#FIG 3: Comparing by groups
#####Creating the df I'll need 
```{r}
library(dplyr)
library(tidyr)

merged_clean_data <- merged_data %>% 
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2.x, everything()) %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0))) %>%   # replace NAs with 0
  group_by(site, site_type, zone, year) %>%
  summarise(across(where(is.numeric), mean), .groups = "drop") %>%
  mutate(site_type = as.factor(site_type))

# scale 20m2 cols to per-m²
cols_to_scale <- grep("20m2", names(merged_clean_data), value = TRUE)
merged_clean_data[cols_to_scale] <- lapply(merged_clean_data[cols_to_scale], function(x) x / 20)

# rename columns (remove "20m2")
names(merged_clean_data) <- gsub("20m2", "", names(merged_clean_data))


###including the predicted patch definitons to the df

#Create unique patch ID using site, predicted 2024 type, and zone
merged <- merged %>%
  mutate(
    patch_id = paste(site, site_type_pred_2024, zone, sep = "_"),
    pred_patch_2024 = site_type_pred_2024,
    pred_patch_2025 = site_type_pred_2025
  ) 

#creating df that has abundances and patch transitions
pred_patch_data <- merged_clean_data %>%
  left_join(
    merged %>%
      dplyr::select(site, zone, site_type, pred_patch_2024, pred_patch_2025),  # match original site_type
    by = c("site", "zone", "site_type")
  ) %>%
  dplyr::select(pred_patch_2024, pred_patch_2025, everything(), -site_type) #move to front and remove original site_type

view(pred_patch_data)

####creating new df with patch transitions
library(vegan)
library(dplyr)

#adding transition column 
patch_trans_data <- pred_patch_data %>%
  mutate(patch_transition = paste(pred_patch_2024, "→", pred_patch_2025)) %>%
  dplyr::select(patch_transition, pred_patch_2024, pred_patch_2025, everything(), -latitude, -longitude)

view(patch_trans_data)

```
#A: BAR -> INCIP
```{r}
# Barren → Incipient
bar_incip <- patch_trans_data %>%
  filter(str_detect(patch_transition, "BAR.*→ INCIP"))
print(bar_incip)

```
##### Boxplot
```{r}
#creating functional groups

functional_groups <- bar_incip %>%
  group_by(patch_transition, site, zone, year) %>%
  summarise(
    first_stage = sum(cov_articulated_coralline + cov_crustose_coralline + cov_encrusting_red, na.rm = TRUE), 
    second_stage = sum(cov_fleshy_red + cov_dictyota_dictyopteris + cov_desmarestia_spp + cov_dictyoneurum_spp, na.rm = TRUE), 
    understory_recruits_juvs = sum(lamr_densitym2 + ptej_densitym2 + lsetj_densitym2, na.rm = TRUE),
    understory_adults = sum(density_ptecal + density_eisarb + density_lamset, na.rm = TRUE), 
    canopy_recruits_juv = sum(macr_densitym2 + macj_densitym2 + nerj_densitym2, na.rm = TRUE), 
    canopy_adults = sum(macro_stipe_density_.x + density_nerlue, na.rm = TRUE),
    purple_urchins = sum(purple_urchin_densitym2, na.rm = TRUE),
    purple_urchin_conceiled = sum(purple_urchin_conceiledm2, na.rm = TRUE),
    .groups = "drop"
  )


#aggregating functional groups 
functional_groups_agg <- functional_groups %>%
  mutate(across(c(first_stage, second_stage, understory_recruits_juvs, understory_adults, 
                  canopy_recruits_juv, canopy_adults, purple_urchins, purple_urchin_conceiled),
                ~ (.-mean(.))/sd(.)))

#pivoting longer
data_long <- functional_groups_agg %>%
  pivot_longer(
    cols = c(first_stage, second_stage, understory_recruits_juvs, understory_adults, 
             canopy_recruits_juv, canopy_adults, purple_urchins, purple_urchin_conceiled),
    names_to = "functional_group",
    values_to = "value"
  )

#turning functional groups into factors
data_long <- data_long %>%
  mutate(functional_group = factor(functional_group, 
                                   levels = c("first_stage", "second_stage", 
                                              "understory_recruits_juvs", "understory_adults", 
                                              "canopy_recruits_juv", "canopy_adults", 
                                              "purple_urchins", "purple_urchin_conceiled")))


# Define stages for shaded backgrounds
stages <- data.frame(
  start = c(0.5, 2.5, 4.5, 6.5),
  end   = c(2.5, 4.5, 6.5, 8.5),
  stage = c("Early", "Understory", "Canopy", "Urchins")
)


# BOX PLOT WITH ALL FUNCTIONAL GROUPS
ggplot(data_long, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95", "gray97", "gray95", "gray97"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5, 3.5, 5.5, 7.5), y = max(data_long$value) + 0.5,
           label = stages$stage, fontface = "bold", size = 4)


#JUST ALGAL GROUPS
algal_groups <- data_long %>%
  filter(!functional_group %in% c("purple_urchins", "purple_urchin_conceiled"))

stages_algae <- data.frame(
  start = c(0.5, 2.5, 4.5),
  end   = c(2.5, 4.5, 6.5),
  stage = c("Early", "Understory", "Canopy")
)


ggplot(algal_groups, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages_algae, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95", "gray97", "gray95"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5, 3.5, 5.5), y = max(data_long$value) + 0.5,
           label = stages_algae$stage, fontface = "bold", size = 4)


#JUST URCHIN GROUPS
urchin_groups <- data_long %>%
  filter(functional_group %in% c("purple_urchins", "purple_urchin_conceiled"))

stages_urchin <- data.frame(
  start = c(0.5),
  end   = c(2.5),
  stage = "Urchins"
)


ggplot(urchin_groups, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages_urchin, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5), y = max(urchin_groups$value) + 0.5,
           label = stages_urchin$stage, fontface = "bold", size = 4)
```
###Stats (ANOVA)
```{r}
# Columns for functional groups
cols <- c("first_stage", "second_stage", "understory_recruits_juvs",
          "understory_adults", "canopy_recruits_juv", "canopy_adults",
          "purple_urchins", "purple_urchin_conceiled")

# Prepare raw long-format data
raw_groups <- functional_groups %>%
  dplyr::select(site, zone, year, all_of(cols)) %>%
  pivot_longer(
    cols = all_of(cols),
    names_to = "functional_group",
    values_to = "value"
  )

# Function to check assumptions and run ANOVA, with optional log(x+1) transformation
anova_check_log <- function(df) {
  # Original ANOVA
  aov_model <- aov(value ~ factor(year), data = df)
  res <- residuals(aov_model)
  shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
  levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                        error = function(e) NA)
  
  # If assumptions fail, log-transform and rerun
  if(is.na(shapiro_p) | is.na(levene_p) | shapiro_p <= 0.05 | levene_p <= 0.05) {
    df <- df %>% mutate(value = log(value + 1))
    aov_model <- aov(value ~ factor(year), data = df)
    res <- residuals(aov_model)
    shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
    levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                          error = function(e) NA)
    transformed <- TRUE
  } else {
    transformed <- FALSE
  }
  
  # Extract ANOVA results
  tidy_res <- broom::tidy(aov_model) %>% filter(term == "factor(year)")
  f_val <- tidy_res$statistic
  p_val <- tidy_res$p.value
  
  tibble(
    functional_group = unique(df$functional_group),
    shapiro_p = shapiro_p,
    levene_p = levene_p,
    transformed = transformed,
    F_value = f_val,
    p_value = p_val
  )
}

# Apply function to all functional groups
anova_summary <- raw_groups %>%
  group_by(functional_group) %>%
  group_modify(~ anova_check_log(.x)) %>%
  ungroup()

# View results
anova_summary


# Format ANOVA summary for the table
anova_table <- anova_summary %>%
  dplyr::select(functional_group, F_value, p_value, transformed) %>%
  mutate(p_value = signif(p_value, 3))  # Round p-values

# Create a table figure
ggtexttable(anova_table,
            rows = NULL,       # remove row names
            theme = ttheme("classic"))

```

```{r}

# Create significance labels based on p-value
anova_summary <- anova_summary %>%
  mutate(sig_label = case_when(
    p_value <= 0.001 ~ "***",
    p_value <= 0.01  ~ "**",
    p_value <= 0.05  ~ "*",
    TRUE             ~ ""
  ))

# Compute maximum y-value per functional group for annotation placement
y_max <- data_long %>%
  group_by(functional_group) %>%
  summarise(y_pos = max(value) + 0.2, .groups = "drop")

# Join y_max with significance labels
sig_annot <- anova_summary %>%
  left_join(y_max, by = "functional_group")

# Boxplot with significance annotations
ggplot(data_long, aes(x = functional_group, y = value, fill = factor(year))) +
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  geom_jitter(aes(color = factor(year)),
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75),
              size = 2) +
  
  # Add ANOVA significance annotations
  geom_text(data = sig_annot, aes(x = functional_group, y = y_pos, label = sig_label),
            inherit.aes = FALSE, vjust = 0) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  )

```

#B: INCIP -> FOR
```{r}
# Barren → Incipient
incip_for <- patch_trans_data %>%
  filter(str_detect(patch_transition, "INCIP.*→ FOR"))
print(incip_for)

```
### Boxplot
```{r}
#creating functional groups

functional_groups_2 <- incip_for %>%
  group_by(patch_transition, site, zone, year) %>%
  summarise(
    first_stage = sum(cov_articulated_coralline + cov_crustose_coralline + cov_encrusting_red, na.rm = TRUE), 
    second_stage = sum(cov_fleshy_red + cov_dictyota_dictyopteris + cov_desmarestia_spp + cov_dictyoneurum_spp, na.rm = TRUE), 
    understory_recruits_juvs = sum(lamr_densitym2 + ptej_densitym2 + lsetj_densitym2, na.rm = TRUE),
    understory_adults = sum(density_ptecal + density_eisarb + density_lamset, na.rm = TRUE), 
    canopy_recruits_juv = sum(macr_densitym2 + macj_densitym2 + nerj_densitym2, na.rm = TRUE), 
    canopy_adults = sum(macro_stipe_density_.x + density_nerlue, na.rm = TRUE),
    purple_urchins = sum(purple_urchin_densitym2, na.rm = TRUE),
    purple_urchin_conceiled = sum(purple_urchin_conceiledm2, na.rm = TRUE),
    .groups = "drop"
  )


#aggregating functional groups 
functional_groups_agg_2 <- functional_groups_2 %>%
  mutate(across(c(first_stage, second_stage, understory_recruits_juvs, understory_adults, 
                  canopy_recruits_juv, canopy_adults, purple_urchins, purple_urchin_conceiled),
                ~ (.-mean(.))/sd(.)))

#pivoting longer
data_long_2 <- functional_groups_agg_2 %>%
  pivot_longer(
    cols = c(first_stage, second_stage, understory_recruits_juvs, understory_adults, 
             canopy_recruits_juv, canopy_adults, purple_urchins, purple_urchin_conceiled),
    names_to = "functional_group",
    values_to = "value"
  )

#turning functional groups into factors
data_long_2 <- data_long_2 %>%
  mutate(functional_group= factor(functional_group, 
                                   levels = c("first_stage", "second_stage", 
                                              "understory_recruits_juvs", "understory_adults", 
                                              "canopy_recruits_juv", "canopy_adults", 
                                              "purple_urchins", "purple_urchin_conceiled")))


# Define stages for shaded backgrounds
stages_2 <- data.frame(
  start = c(0.5, 2.5, 4.5, 6.5),
  end   = c(2.5, 4.5, 6.5, 8.5),
  stage = c("Early", "Understory", "Canopy", "Urchins")
)


# BOX PLOT WITH ALL FUNCTIONAL GROUPS
ggplot(data_long_2, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages_2, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95", "gray97", "gray95", "gray97"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5, 3.5, 5.5, 7.5), y = max(data_long$value) + 0.5,
           label = stages_2$stage, fontface = "bold", size = 4)


#JUST ALGAL GROUPS
algal_groups <- data_long_2 %>%
  filter(!functional_group %in% c("purple_urchins", "purple_urchin_conceiled"))

stages_algae <- data.frame(
  start = c(0.5, 2.5, 4.5),
  end   = c(2.5, 4.5, 6.5),
  stage = c("Early", "Understory", "Canopy")
)


ggplot(algal_groups, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages_algae, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95", "gray97", "gray95"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5, 3.5, 5.5), y = max(data_long$value) + 0.5,
           label = stages_algae$stage, fontface = "bold", size = 4)


#JUST URCHIN GROUPS
urchin_groups <- data_long_2 %>%
  filter(functional_group %in% c("purple_urchins", "purple_urchin_conceiled"))

stages_urchin <- data.frame(
  start = c(0.5),
  end   = c(2.5),
  stage = "Urchins"
)


ggplot(urchin_groups, aes(x = functional_group, y = value, fill = factor(year))) +
  # Shaded bands for ecological stages
  geom_rect(data = stages_urchin, 
            aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE,
            fill = c("gray95"), alpha = 0.4) +
  
  geom_boxplot(width = 0.6, position = position_dodge(width = 0.75), outlier.shape = NA) +
  
  # Overlay points for transparency
  geom_jitter(aes(color = factor(year)), position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), size = 2) +
  
  # Labels & theme
  labs(
    x = NULL,
    y = "Standardized Value (z-score)",
    fill = "Year",
    color = "Year"
  ) +
  scale_fill_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  scale_color_manual(values = c("2024" = "#56B4E9", "2025" = "#E69F00")) +
  
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray85")
  ) +
  
  # Optional: stage labels on top
  annotate("text", x = c(1.5), y = max(urchin_groups$value) + 0.5,
           label = stages_urchin$stage, fontface = "bold", size = 4)
```

###Stats (ANOVA)
```{r}
# Columns for functional groups
cols <- c("first_stage", "second_stage", "understory_recruits_juvs",
          "understory_adults", "canopy_recruits_juv", "canopy_adults",
          "purple_urchins", "purple_urchin_conceiled")

# Prepare raw long-format data
raw_groups <- functional_groups_2 %>%
  dplyr::select(site, zone, year, all_of(cols)) %>%
  pivot_longer(
    cols = all_of(cols),
    names_to = "functional_group",
    values_to = "value"
  )

# Function to check assumptions and run ANOVA, with optional log(x+1) transformation
anova_check_log <- function(df) {
  # Original ANOVA
  aov_model <- aov(value ~ factor(year), data = df)
  res <- residuals(aov_model)
  shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
  levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                        error = function(e) NA)
  
  # If assumptions fail, log-transform and rerun
  if(is.na(shapiro_p) | is.na(levene_p) | shapiro_p <= 0.05 | levene_p <= 0.05) {
    df <- df %>% mutate(value = log(value + 1))
    aov_model <- aov(value ~ factor(year), data = df)
    res <- residuals(aov_model)
    shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
    levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                          error = function(e) NA)
    transformed <- TRUE
  } else {
    transformed <- FALSE
  }
  
  # Extract ANOVA results
  tidy_res <- broom::tidy(aov_model) %>% filter(term == "factor(year)")
  f_val <- tidy_res$statistic
  p_val <- tidy_res$p.value
  
  tibble(
    functional_group = unique(df$functional_group),
    shapiro_p = shapiro_p,
    levene_p = levene_p,
    transformed = transformed,
    F_value = f_val,
    p_value = p_val
  )
}

# Apply function to all functional groups
anova_summary <- raw_groups %>%
  group_by(functional_group) %>%
  group_modify(~ anova_check_log(.x)) %>%
  ungroup()

# View results
anova_summary

library(ggpubr)

# Format ANOVA summary for the table
anova_table <- anova_summary %>%
  dplyr::select(functional_group, F_value, p_value, transformed) %>%
  mutate(p_value = signif(p_value, 3))  # Round p-values

# Create a table figure
ggtexttable(anova_table,
            rows = NULL,       # remove row names
            theme = ttheme("classic"))

```



#FIG4: Comparing by species
##A: BAR -> INCIP
###Barplot
```{r}

# 1. Summarize density and cover by patch_transition, zone, site, year
individual_sp <- bar_incip %>%
  group_by(patch_transition, zone, site, year) %>%
  summarise(across(
    c(macro_stipe_density_.x, macj_densitym2, macr_densitym2, density_nerlue, nerj_densitym2,
      density_ptecal, ptej_densitym2, lamr_densitym2, density_lamset, lsetj_densitym2,
      purple_urchin_densitym2, purple_urchin_conceiledm2, cov_articulated_coralline,
      cov_crustose_coralline, cov_encrusting_red, cov_fleshy_red, cov_stephanocystis,
      cov_desmarestia_spp),
    sum,
    .names = "{.col}"
  )) %>%
  rename(
    macrocystis_adults = macro_stipe_density_.x,
    macrocystis_juveniles = macj_densitym2,
    macrocystis_recruits = macr_densitym2,
    nereocystis_adults = density_nerlue,
    nereocystis_juveniles = nerj_densitym2,
    pterogophora_adults = density_ptecal,
    pterogrophora_juveniles = ptej_densitym2,
    laminariales_spp_recruits = lamr_densitym2,
    lam_setchellii_adults = density_lamset,
    lam_setchellii_juveniles = lsetj_densitym2,
    total_purple_urchins = purple_urchin_densitym2,
    conceiled_purple_urchins = purple_urchin_conceiledm2,
    articulated_coralline = cov_articulated_coralline,
    crustose_coralline = cov_crustose_coralline,
    encrusting_red = cov_encrusting_red,
    fleshy_reds = cov_fleshy_red,
    stephanocystis_adult = cov_stephanocystis,
    desmerestia_spp = cov_desmarestia_spp
  ) %>%
  ungroup()

# 2. Pivot longer
indv_long <- individual_sp %>%
  pivot_longer(
    cols = macrocystis_adults:desmerestia_spp,
    names_to = "individual_species",
    values_to = "value"
  ) %>%
  mutate(value_log = log1p(value))  # log-transform for skewed counts

# 3. Define groups
cover_species <- c("articulated_coralline", "crustose_coralline", "encrusting_red",
                   "fleshy_reds", "stephanocystis_adult", "desmerestia_spp")
urchins <- c("total_purple_urchins", "conceiled_purple_urchins")

algae <- c(  "laminariales_spp_recruits",
  "lam_setchellii_juveniles", 
  "pterogrophora_juveniles", 
  "lam_setchellii_adults", 
  "pterogophora_adults", 
  "nereocystis_juveniles", 
  "nereocystis_adults", 
  "macrocystis_recruits", 
  "macrocystis_juveniles", 
  "macrocystis_adults")

```
####Macroalgae 
```{r}
# 4. Filter algae density only (exclude cover & urchins)
alg_density_long <- indv_long %>%
  filter(!individual_species %in% c(cover_species, urchins))

# Define species order for plotting
species_order <- c(
  "laminariales_spp_recruits",
  "lam_setchellii_juveniles", 
  "pterogrophora_juveniles", 
  "lam_setchellii_adults", 
  "pterogophora_adults", 
  "nereocystis_juveniles", 
  "nereocystis_adults", 
  "macrocystis_recruits", 
  "macrocystis_juveniles", 
  "macrocystis_adults"
)

alg_density_long <- alg_density_long %>%
  mutate(individual_species = factor(individual_species, levels = species_order))


algal_density_summary <- alg_density_long %>%
  group_by(year, individual_species) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    se_value = sd_value / sqrt(n),
    .groups = "drop" 
  )


ggplot(algal_density_summary, aes(x = individual_species, y = mean_value, fill = factor(year))) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value),
                position = position_dodge(0.8), width = 0.2, color = "black") +
  geom_jitter(data = alg_density_long, 
              aes(x = individual_species, y = value, color = factor(year)),
              position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
              size = 1.5, alpha = 0.6, inherit.aes = FALSE) +
# Fixed y-axis for readability
  coord_cartesian(ylim = c(0, 0.9))+
  scale_fill_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  scale_color_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  labs(x = NULL, y = "Mean density (m²)", fill = "Year", color = "Year") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        axis.title.y = element_text(face = "bold"),
        legend.position = "top",
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray85"))

```

####Cover algae
```{r}
# 4. Filter algae density only (exclude cover & urchins)
cov_density_long <- indv_long %>%
  filter(!individual_species %in% c(algae, urchins))

# Define species order for plotting
species_order <- c(
  "articulated_coralline", "crustose_coralline", "encrusting_red",
                   "fleshy_reds", "stephanocystis_adult", "desmerestia_spp"
)

cov_density_long <- cov_density_long %>%
  mutate(individual_species = factor(individual_species, levels = species_order))


cov_density_summary <- cov_density_long %>%
  group_by(year, individual_species) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    se_value = sd_value / sqrt(n),
    .groups = "drop" 
  )


ggplot(cov_density_summary, aes(x = individual_species, y = mean_value, fill = factor(year))) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value),
                position = position_dodge(0.8), width = 0.2, color = "black") +
  geom_jitter(data = cov_density_long, 
              aes(x = individual_species, y = value, color = factor(year)),
              position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
              size = 1.5, alpha = 0.6, inherit.aes = FALSE) +
# Fixed y-axis for readability
  coord_cartesian(ylim = c(0, 55))+
  scale_fill_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  scale_color_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  labs(x = NULL, y = "% Cover (m²)", fill = "Year", color = "Year") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        axis.title.y = element_text(face = "bold"),
        legend.position = "top",
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray85"))

```

###Stats (ANOVA)
```{r}
anova_check_log <- function(df) {
  # ANOVA model for each species
  aov_model <- aov(value ~ factor(year), data = df)
  res <- residuals(aov_model)
  shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
  levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                        error = function(e) NA)
  
  # If assumptions fail, log-transform and rerun
  if(is.na(shapiro_p) | is.na(levene_p) | shapiro_p <= 0.05 | levene_p <= 0.05) {
    df <- df %>% mutate(value = log(value + 1))
    aov_model <- aov(value ~ factor(year), data = df)
    res <- residuals(aov_model)
    shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
    levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                          error = function(e) NA)
    transformed <- TRUE
  } else {
    transformed <- FALSE
  }
  
  # Extract ANOVA results
  tidy_res <- broom::tidy(aov_model) %>% filter(term == "factor(year)")
  f_val <- tidy_res$statistic
  p_val <- tidy_res$p.value
  
  tibble(
    individual_species = unique(df$individual_species),
    shapiro_p = shapiro_p,
    levene_p = levene_p,
    transformed = transformed,
    F_value = f_val,
    p_value = p_val
  )
}

# Apply function to all species
anova_summary <- indv_long %>%
  group_by(individual_species) %>%
  group_modify(~ anova_check_log(.x)) %>%
  ungroup()

# View results
anova_summary

# Format ANOVA summary for the table
anova_table <- anova_summary %>%
  dplyr::select(individual_species, F_value, p_value, transformed) %>%
  mutate(p_value = signif(p_value, 3))  # Round p-values

# Create a table figure
ggtexttable(anova_table,
            rows = NULL,       # remove row names
            theme = ttheme("classic"))
```


##B: INCIP -> FOR
###Barplot
```{r}

# 1. Summarize density and cover by patch_transition, zone, site, year
individual_sp_for <- incip_for %>%
  group_by(patch_transition, zone, site, year) %>%
  summarise(across(
    c(macro_stipe_density_.x, macj_densitym2, macr_densitym2, density_nerlue, nerj_densitym2,
      density_ptecal, ptej_densitym2, lamr_densitym2, density_lamset, lsetj_densitym2,
      purple_urchin_densitym2, purple_urchin_conceiledm2, cov_articulated_coralline,
      cov_crustose_coralline, cov_encrusting_red, cov_fleshy_red, cov_stephanocystis,
      cov_desmarestia_spp),
    sum,
    .names = "{.col}"
  )) %>%
  rename(
    macrocystis_adults = macro_stipe_density_.x,
    macrocystis_juveniles = macj_densitym2,
    macrocystis_recruits = macr_densitym2,
    nereocystis_adults = density_nerlue,
    nereocystis_juveniles = nerj_densitym2,
    pterogophora_adults = density_ptecal,
    pterogrophora_juveniles = ptej_densitym2,
    laminariales_spp_recruits = lamr_densitym2,
    lam_setchellii_adults = density_lamset,
    lam_setchellii_juveniles = lsetj_densitym2,
    total_purple_urchins = purple_urchin_densitym2,
    conceiled_purple_urchins = purple_urchin_conceiledm2,
    articulated_coralline = cov_articulated_coralline,
    crustose_coralline = cov_crustose_coralline,
    encrusting_red = cov_encrusting_red,
    fleshy_reds = cov_fleshy_red,
    stephanocystis_adult = cov_stephanocystis,
    desmerestia_spp = cov_desmarestia_spp
  ) %>%
  ungroup()

# 2. Pivot longer
indv_long_for <- individual_sp_for %>%
  pivot_longer(
    cols = macrocystis_adults:desmerestia_spp,
    names_to = "individual_species",
    values_to = "value"
  ) %>%
  mutate(value_log = log1p(value))  # log-transform for skewed counts

# 3. Define groups
cover_species <- c("articulated_coralline", "crustose_coralline", "encrusting_red",
                   "fleshy_reds", "stephanocystis_adult", "desmerestia_spp")
urchins <- c("total_purple_urchins", "conceiled_purple_urchins")

algae <- c(  "laminariales_spp_recruits",
  "lam_setchellii_juveniles", 
  "pterogrophora_juveniles", 
  "lam_setchellii_adults", 
  "pterogophora_adults", 
  "nereocystis_juveniles", 
  "nereocystis_adults", 
  "macrocystis_recruits", 
  "macrocystis_juveniles", 
  "macrocystis_adults")

```
```{r}
# 4. Filter algae density only (exclude cover & urchins)
alg_density_long_for <- indv_long_for %>%
  filter(!individual_species %in% c(cover_species, urchins))

# Define species order for plotting
species_order <- c(
  "laminariales_spp_recruits",
  "lam_setchellii_juveniles", 
  "pterogrophora_juveniles", 
  "lam_setchellii_adults", 
  "pterogophora_adults", 
  "nereocystis_juveniles", 
  "nereocystis_adults", 
  "macrocystis_recruits", 
  "macrocystis_juveniles", 
  "macrocystis_adults"
)

alg_density_long_for <- alg_density_long_for %>%
  mutate(individual_species = factor(individual_species, levels = species_order))


algal_density_summary_for <- alg_density_long_for %>%
  group_by(year, individual_species) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    se_value = sd_value / sqrt(n),
    .groups = "drop" 
  )


ggplot(algal_density_summary_for, aes(x = individual_species, y = mean_value, fill = factor(year))) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value),
                position = position_dodge(0.8), width = 0.2, color = "black") +
  geom_jitter(data = alg_density_long, 
              aes(x = individual_species, y = value, color = factor(year)),
              position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),
              size = 1.5, alpha = 0.6, inherit.aes = FALSE) +
# Fixed y-axis for readability
  coord_cartesian(ylim = c(0, 3.3))+
  scale_fill_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  scale_color_manual(values = c("2024" = "#1f77b4", "2025" = "#ff7f0e")) +
  labs(x = NULL, y = "Mean density (m²)", fill = "Year", color = "Year") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        axis.title.y = element_text(face = "bold"),
        legend.position = "top",
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.y = element_line(color = "gray85"))

```

###Stats (ANOVA)
```{r}
anova_check_log <- function(df) {
  # ANOVA model for each species
  aov_model <- aov(value ~ factor(year), data = df)
  res <- residuals(aov_model)
  shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
  levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                        error = function(e) NA)
  
  # If assumptions fail, log-transform and rerun
  if(is.na(shapiro_p) | is.na(levene_p) | shapiro_p <= 0.05 | levene_p <= 0.05) {
    df <- df %>% mutate(value = log(value + 1))
    aov_model <- aov(value ~ factor(year), data = df)
    res <- residuals(aov_model)
    shapiro_p <- tryCatch(shapiro.test(res)$p.value, error = function(e) NA)
    levene_p <- tryCatch(leveneTest(value ~ factor(year), data = df)$`Pr(>F)`[1], 
                          error = function(e) NA)
    transformed <- TRUE
  } else {
    transformed <- FALSE
  }
  
  # Extract ANOVA results
  tidy_res <- broom::tidy(aov_model) %>% filter(term == "factor(year)")
  f_val <- tidy_res$statistic
  p_val <- tidy_res$p.value
  
  tibble(
    individual_species = unique(df$individual_species),
    shapiro_p = shapiro_p,
    levene_p = levene_p,
    transformed = transformed,
    F_value = f_val,
    p_value = p_val
  )
}

# Apply function to all species
anova_summary <- indv_long_for %>%
  group_by(individual_species) %>%
  group_modify(~ anova_check_log(.x)) %>%
  ungroup()

# View results
anova_summary

# Format ANOVA summary for the table
anova_table <- anova_summary %>%
  dplyr::select(individual_species, F_value, p_value, transformed) %>%
  mutate(p_value = signif(p_value, 3))  # Round p-values

# Create a table figure
ggtexttable(anova_table,
            rows = NULL,       # remove row names
            theme = ttheme("classic"))
```


#FIG 4:


##4a: RDA for BAR -> INCIP
```{r}

# Barren → Incipient
bar_incip <- patch_trans_data %>%
  filter(str_detect(patch_transition, "BAR.*→ INCIP"))


#isolate algal species
algal_cols <- c(
  "cov_articulated_coralline", "cov_crustose_coralline",
  "cov_encrusting_red", "cov_fleshy_red", "cov_lam_holdfast_live",
  "cov_mac_holdfast_live", "cov_dictyoneurum_spp",
  "cov_desmarestia_spp", "cov_stephanocystis",  "macro_stipe_density_.x", "density_ptecal", "density_nerlue", "density_lamset", 
    "density_eisarb", 
    "lamr_densitym2", "macr_densitym2", "macj_densitym2", "nerj_densitym2", 
    "ptej_densitym2", "lsetj_densitym2")


#log + 1 transform 
bar_incip_log <- bar_incip %>%
  mutate(across(all_of(algal_cols), ~ log1p(.)))


bar_incip_long <- bar_incip_log %>%
  pivot_longer(
    cols = all_of(algal_cols),
    names_to = "species",
    values_to = "log_cover"
  )


# Create matrix: rows = samples, columns = algal species
algal_matrix <- bar_incip_log %>%
  dplyr::select(all_of(algal_cols))

# Run NMDS using Bray-Curtis distance
set.seed(42)  # for reproducibility
nmds <- metaMDS(algal_matrix, distance = "bray", k = 2, trymax = 100)

nmds

```
