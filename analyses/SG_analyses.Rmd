---
title: "SG_analyses"
author: "Sabrina Grant"
date: "`r Sys.Date()`"
output: html_document
---

#packages
```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# packages
install.packages("librarian")
librarian::shelf("tidyverse", "vegan", "ggplot2", "dplyr", "car", "ggpubr", "minpack.lm", "googledrive", "janitor", "nlme", "RColorBrewer", "splitstackshape", "lubridate", "matrixStats", "readr", "stringr", "broom")

library(googledrive)

```
#loading data
```{r}

# load data
drive_deauth()

drive_auth(scopes = "https://www.googleapis.com/auth/drive")

file <- drive_find("kelp_recovery_data.rda",
                   shared_drive = "MBA_kelp_recovery_research")
file

drive_download(
  as_id(file$id),
  path = "kelp_recovery_data.rda",
  overwrite = TRUE
)

load("kelp_recovery_data.rda")
ls()
```


#Fixing up data frames
```{r}
###averaging counts and % cover per transect

# Helper function to get the most common value (mode)
get_mode <- function(x) {
  ux <- na.omit(unique(x))
  ux[which.max(tabulate(match(x, ux)))]
}

#averaging across quads
quad_transect_avgs <- quad_data %>%
  group_by(site, site_type, zone, survey_date, transect) %>%
  summarise(
    across(where(is.numeric) & !any_of("quadrat"), ~ mean(.x, na.rm = TRUE)),
    substrate = get_mode(substrate),
    .groups = "drop"
  )

#now averaging per survey 
quad_avgs <- quad_transect_avgs %>%
  group_by(site, site_type, zone, survey_date) %>%
  # 1. Create proportion variables (safe division)
  mutate(
    prop_purp_concealedm2 = if_else(
      purple_urchin_densitym2 > 0,
      purple_urchin_conceiledm2 / purple_urchin_densitym2,
      0
    ),
    prop_red_concealedm2 = if_else(
      red_urchin_densitym2 > 0,
      red_urchin_conceiledm2 / red_urchin_densitym2,
      0
    )
  ) %>%
  # 2. Drop the old concealed density columns
  dplyr::select(-purple_urchin_conceiledm2, -red_urchin_conceiledm2) %>%
  # 3. Summarise by group
  summarise(
    across(where(is.numeric) & !any_of("transect"), ~mean(.x, na.rm = TRUE)),
    substrate = get_mode(substrate),
    .groups = "drop"
  )



#averaging transects
kelp_avgs <- kelp_data %>%
  group_by(site, site_type, zone, survey_date) %>%
  summarise( 
    across(where(is.numeric) & !any_of("transect"), ~mean(.x, na.rm = TRUE)), 
    .groups = "drop") 


```



#Merging Quad/Kelp Dfs

```{r}
merged_data <- kelp_avgs %>%
  # Keep coordinates from kelp_avgs
  left_join(
    quad_avgs %>% dplyr::select(-latitude, -longitude),  # drop coords from quad_avgs before join
    by = c("site", "site_type", "zone", "survey_date")
  ) %>%
  mutate(year = as.numeric(format(survey_date, "%Y")))


#creating a new column that just has years for future analysis  
merged_data$year <- as.numeric(format(merged_data$survey_date, "%Y"))

```

#2024 data 
```{r}
#filtering for 2024 data 
year_one_data <- merged_data %>% 
  filter(year == 2024) %>%
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2, everything())

#replaces NAs with zero
year_one_data[sapply(year_one_data, is.numeric)] <-
  lapply(year_one_data[sapply(year_one_data, is.numeric)],
         function(x) { x[is.na(x)] <- 0; x })

#getting mean of numeric values across grouping categories
year_one_data %>%
  group_by(site, site_type, zone, year) %>%
  summarise(
    across(where(is.numeric), \(x) mean(x, na.rm = TRUE)),
    .groups = "drop"
  )

```


##LDA at the depth zone level
```{r}
library(MASS)

#making sure site type is a factor
year_one_data$site_type <- as.factor(year_one_data$site_type)
  
# Identify columns that contain "20m2"
cols_to_scale <- grep("20m2", names(year_one_data), value = TRUE)

# Divide those columns by 20
year_one_data[cols_to_scale] <- lapply(year_one_data[cols_to_scale], function(x) x / 20)

# 3. Rename those columns by removing "20m2_"
names(year_one_data)[names(year_one_data) %in% cols_to_scale] <-
  gsub("20m2","", cols_to_scale)

lda_model <- lda(site_type ~ macro_stipe_density_ + density_ptecal + density_nerlue + density_lamset + density_eisarb + purple_urchin_densitym2 + prop_purp_concealedm2 + lamr + macr + macj + nerj + ptej + lsetj + cov_articulated_coralline + cov_crustose_coralline + cov_encrusting_red + cov_fleshy_red + cov_stephanocystis + cov_dictyoneurum_spp  + cov_desmarestia_spp + cov_lam_holdfast_live + cov_mac_holdfast_live + cov_bare_rock + cov_bare_sand + cov_shell_debris, data = year_one_data)


#lda figure
plot(lda_model)

#lda summary
lda_model

#getting predictions etc etc 
pred <- predict(lda_model)
pred_class <- pred$class

library(caret)
#getting % accuracy
confusionMatrix(pred_class, year_one_data$site_type)

results <- year_one_data %>%
  mutate(predicted = pred_class, 
         match = site_type == predicted)

#seeing mismatches 
results <- results %>%
  dplyr::select(year, site, zone, site_type, predicted, match, everything())

mismatches <- results %>% filter(!match)

```


##coefficients of LDA
```{r}
library(tidyr)

# Get coefficients into tidy format
coef_df <- as.data.frame(lda_model$scaling)
coef_df$variable <- rownames(coef_df)
coef_long <- pivot_longer(coef_df, cols = c(LD1, LD2), names_to = "LD", values_to = "coefficient")

# Plot
ggplot(coef_long, aes(x = reorder(variable, coefficient), y = coefficient, fill = LD)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  theme_minimal(base_size = 14) +
  labs(
    title = "LDA Coefficients by Discriminant Function",
    x = "Variable",
    y = "Coefficient"
  ) +
  scale_fill_brewer(palette = "Set1")


#renaming variables and selecting for strong coefficients
rename_vars <- c(
  "density_eisarb"        = "E. arborea",
  "macj"        = "M. pyrifera juvenile",
  "lsetj"       = "L. setchellii juvenile",
  "lamr"        = "Laminariales recruit", 
  "ptej"        = "P. californica juvenile", 
  "density_ptecal"        = "P. californica", 
  "cov_dictyoneurum_spp"  = "Dictyoneurum spp.", 
  "cov_mac_holdfast_live" = "M. pyrifera holdfast", 
  "macro_stipe_density_"= "M. pyrifera", 
  "macr"        = "M. pyrifera recruit", 
  "density_nerlue"        = "N. luetkeana", 
  "nerj"        = "N. luetkeana juvenile", 
  "density_lamset" = "L. setchellii", 
  "prop_purp_concealedm2" = "Concealed purple urchins (prop)"
)

coef_strong <- coef_long %>%
  filter(abs(coefficient) > 3) %>%
  mutate(
    variable = recode_factor(variable, !!!rename_vars),
    variable = reorder(variable, abs(coefficient))
  )


#plotting coefficients
ggplot(coef_strong, aes(
  x = variable,
  y = coefficient,
  fill = LD
)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  coord_flip() +
  theme_minimal(base_size = 14) +
  theme(
   element_blank(), panel.grid.major = element_line(color = "white", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    axis.text.y = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  labs(
    title = "",
    x = "Variable",
    y = ""
  ) +
  scale_fill_brewer(palette = "Set1")

```

#FIG 1: LDA of 2024 Patch Discrimination
```{r}
library(ggplot2)
library(dplyr)
library(MASS)
library(grid)  # for arrows

# Get LDA scores 
lda_scores <- as.data.frame(predict(lda_model)$x) 
lda_scores$site_type <- year_one_data$site_type 

# Plot LD1 vs LD2 
ggplot(lda_scores, aes(x = LD1, y = LD2, color = site_type, shape = site_type)) + geom_point(size = 3.5, alpha = 0.9) + 
  stat_ellipse(level = 0.95, size = 1, alpha = 0.6) + 
  scale_color_brewer(palette = "Set1") + 
  theme_minimal(base_size = 16) + 
  labs( title = "", subtitle = "", x = paste0("LD1 (", round(lda_model$svd[1]^2 / sum(lda_model$svd^2) * 100, 1), "%)"), y = paste0("LD2 (", round(lda_model$svd[2]^2 / sum(lda_model$svd^2) * 100, 1), "%)"), color = "Site Type", shape = "Site Type" ) + 
  theme( plot.title = element_text(face = "bold", size = 20, hjust = 0.5, margin = margin(b = 10)), plot.subtitle = element_text(size = 14, hjust = 0.5, margin = margin(b = 15)), axis.title = element_text(face = "bold", size = 15), axis.text = element_text(size = 13), legend.title = element_text(face = "bold", size = 14), legend.text = element_text(size = 12), panel.grid.minor = element_blank(), panel.grid.major = element_line(color = "white", linewidth = 0.3) )


```



##2025 data
##creating new df
```{r}
#filtering to just select for 2025 data 
year_two_data <- merged_data %>% 
  filter(year == 2025) %>%
  filter() %>%
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2, everything())

  
# Identify columns that contain "20m2"
cols_to_scale <- grep("20m2", names(year_two_data), value = TRUE)

# Divide those columns by 20
year_two_data[cols_to_scale] <- lapply(year_two_data[cols_to_scale], function(x) x / 20)

# 3. Rename those columns by removing "20m2_"
names(year_two_data)[names(year_two_data) %in% cols_to_scale] <-
  gsub("20m2","", cols_to_scale)


year_two_data[sapply(year_two_data, is.numeric)] <-
  lapply(year_two_data[sapply(year_two_data, is.numeric)],
         function(x) { x[is.na(x)] <- 0; x })

year_two_data %>%
  group_by(site, site_type, zone, year) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "drop")
  

print(year_two_data)
```

##using 2024 LDA to predict 2025
```{r}

library(MASS)
library(dplyr)

#predicting 2025 patch types based on model
pred_2025 <- predict(lda_model, newdata = year_two_data)


year_two_data <- year_two_data %>%
  dplyr::mutate(site_type_pred = pred_2025$class) %>%
  dplyr::select(year, site, zone, site_type, site_type_pred, dplyr::everything())


#setting up the 2024 df with the predictions column 
pred_2024 <- predict(lda_model, newdata = year_one_data)
year_one_data$site_type_pred <- pred_2024$class

year_one_data <- year_one_data %>%
  dplyr::mutate(site_type_pred = pred_2024$class) %>%
  dplyr::select(year, site, zone, site_type, site_type_pred, dplyr::everything())


##REJOINING 2024 AND 2025 DFS

# Rename the column first
year_one_renamed <- year_one_data %>%
  dplyr::rename(site_type_pred_2024 = site_type_pred) %>%
  dplyr::select(site, zone, site_type, site_type_pred_2024)

year_two_renamed <- year_two_data %>%
  dplyr::rename(site_type_pred_2025 = site_type_pred) %>%
  dplyr::select(site, zone, site_type, site_type_pred_2025)

#merge
merged <- dplyr::left_join(year_one_renamed, year_two_renamed, by = c("site", "zone", "site_type"))


#cross-tabulate 2024 predictions with 2025
library(dplyr)

merged <- year_one_data %>%
  dplyr::select(site, zone, site_type, site_type_pred_2024 = site_type_pred) %>%
  left_join(
    year_two_data %>%
      dplyr::select(site, zone, site_type, site_type_pred_2025 = site_type_pred),
    by = c("site", "zone", "site_type")
  )

cross_tab <- table(merged$site_type_pred_2024, merged$site_type_pred_2025)

cross_tab
```

#FIG 2: Heatmap of Predicted Patch Transitions
```{r}
library(ggplot2)
library(reshape2)
library(viridis)

# Melt the table
cross_tab_melt <- reshape2::melt(cross_tab)

# changing the order of the variables for my plot
desired_order_2024 <- c("BAR", "INCIP", "FOR") 
desired_order_2025 <- c("BAR", "INCIP", "FOR")  

# Convert to factors with specified levels
cross_tab_melt$Var1 <- factor(cross_tab_melt$Var1, levels = desired_order_2024)
cross_tab_melt$Var2 <- factor(cross_tab_melt$Var2, levels = desired_order_2025)

#map colors
my_colors <- brewer.pal(11, "Blues")


# Sleek publication-ready heatmap
ggplot(cross_tab_melt, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "grey90", linewidth = 0.3) +
  geom_text(aes(label = value), 
            color = ifelse(cross_tab_melt$value > max(cross_tab_melt$value)/2, "white", "black"), 
            size = 5, fontface = "bold") +
 scale_fill_gradientn(colors = my_colors) +
  labs(
    x = "2024",
    y = "2025",
    title = "Transition of Predicted Patch Types from 2024 to 2025",
    fill = "Count"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 13),
    axis.text.y = element_text(face = "bold", size = 13),
    axis.title = element_text(face = "bold", size = 14),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 18, margin = margin(b = 10)),
    legend.title = element_text(face = "bold", size = 13),
    legend.text = element_text(size = 12),
    panel.grid = element_blank()
  )


```



#Creating Patch Transition DFs
```{r}
library(dplyr)
library(tidyr)


merged_clean_data <- merged_data %>% 
  dplyr::select(year, site, zone, site_type, macro_stipe_density_20m2, everything()) %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0))) %>%   # replace NAs with 0
  group_by(site, site_type, zone, year) %>%
  summarise(across(where(is.numeric), mean), .groups = "drop") %>%
  mutate(site_type = as.factor(site_type))

# scale 20m2 cols to per-m²
cols_to_scale <- grep("20m2", names(merged_clean_data), value = TRUE)
merged_clean_data[cols_to_scale] <- lapply(merged_clean_data[cols_to_scale], function(x) x / 20)

# rename columns (remove "20m2")
names(merged_clean_data) <- gsub("20m2", "", names(merged_clean_data))


###including the predicted patch definitions to the df

#Create unique patch ID using site, predicted 2024 type, and zone
merged <- merged %>%
  mutate(
    patch_id = paste(site, site_type_pred_2024, zone, sep = "_"),
    pred_patch_2024 = site_type_pred_2024,
    pred_patch_2025 = site_type_pred_2025
  ) 

#creating df that has abundances and patch transitions
pred_patch_data <- merged_clean_data %>%
  left_join(
    merged %>%
      dplyr::select(site, zone, site_type, pred_patch_2024, pred_patch_2025),  # match original site_type
    by = c("site", "zone", "site_type")
  ) %>%
  dplyr::select(pred_patch_2024, pred_patch_2025, everything(), -site_type) #move to front and remove original site_type


####creating new df with patch transitions
patch_trans_data <- pred_patch_data %>%
  mutate(
    # assign the correct prediction for each year
    pred_patch = case_when(
      year == 2024 ~ as.character(pred_patch_2024),
      year == 2025 ~ as.character(pred_patch_2025),
      TRUE ~ NA_character_
    ),
    # create the transition column
    patch_transition = paste(pred_patch_2024, "→", pred_patch_2025)
  ) %>%
  # drop the old wide prediction columns, keep everything else (including species)
  dplyr::select(site, zone, year, pred_patch, patch_transition, everything(), -pred_patch_2024, -pred_patch_2025)


```
#A) BAR -> INCIP
```{r}
# Barren → Incipient
bar_incip <- patch_trans_data %>%
  filter(str_detect(patch_transition, "BAR.*→ INCIP"))
print(bar_incip)
```
#B) INCIP -> FOR
```{r}
# Incipient → Forest
incip_for <- patch_trans_data %>%
  filter(str_detect(patch_transition, "INCIP.*→ FOR"))
print(incip_for)
```
#C) BAR -> FOR
```{r}
#Barren -> Forest
bar_for <- patch_trans_data %>%
  filter(str_detect(patch_transition, "BAR.*→ FOR"))
print(bar_for)
```

#D)BAR24 -> BAR 25, FOR25
```{r}
#Comparing BAR patches which stayed BAR (25) to transitioned BAR patches
bar_bar_for <- patch_trans_data %>%
  filter(str_detect(patch_transition, "BAR.*→ (BAR|FOR)")) %>%
  filter(year == "2025") %>%
  group_by(site, zone, year, pred_patch) %>%
  dplyr::select(c(-patch_transition, -latitude, -longitude, -n_macro_plants_))

print(bar_bar_for)
```



#FIG 3: SIMPER

##B)
###Density species
```{r}
#just selecting for algae species 
density_cols <- c("macro_stipe_density_",  "density_ptecal",
  "density_eisarb", "density_nerlue", "density_lamset",
  "density_lamstump", "density_macstump", "lamr",
  "macr", "macj", "nerj", "ptej",
  "lsetj", "eisj")

#SIMPER on density
comm_density <- incip_for[, density_cols]
group <- as.factor(incip_for$year)  # comparing 2024 vs 2025


sim_density <- simper(comm_density, group, permutations = 0, trace = FALSE)
sim_density_summary <- summary(sim_density, ordered = TRUE, digits = 3)



# Clean & arrange SIMPER results
sim_density_df <- as.data.frame(sim_density_summary$`2024_2025`) %>%
  tibble::rownames_to_column("species") %>%
  filter(!is.na(average), average > 0) %>%
  arrange(desc(average)) %>%
  mutate(
    species = factor(species, levels = rev(species)), # order for plotting
    percent = 100 * average / sum(average),
    cumsum_percent = cumsum(percent)
  )

# Top 10 contributors
top_density <- sim_density_df %>% slice_head(n = 10)

# Plot with cumulative contribution line
ggplot(top_density, aes(x = species, y = percent)) +
  geom_bar(stat = "identity", fill = "cadetblue", color = "black", width = 0.7) +
  geom_line(aes(y = cumsum_percent, group = 1), color = "black", linewidth = 1) +
  geom_point(aes(y = cumsum_percent), color = "black", size = 2, shape = 21, fill = "white") +
  coord_flip() +
  labs(
    title = "Top SIMPER Contributors (Density): INCIP → FOR",
    x = NULL,
    y = "Contribution (%)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.y = element_blank(),   # remove horizontal grid lines
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "grey80", linetype = "dotted"),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )



#showing whether the average abundances increased or decreased from year one to year two 
sim_density_df_2 <- sim_density_df %>%
  mutate(
    change = ifelse(avb > ava, "Increase", "Decrease")
  )

# Top 10 contributors
top_density_2 <- sim_density_df_2 %>% slice_head(n = 10)

ggplot(top_density_2, aes(x = species, y = percent, fill = change)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(
    title = "Top SIMPER Contributors with Direction",
    x = "Species",
    y = "Contribution (%)"
  ) +
  scale_fill_manual(values = c("Increase" = "blue", "Decrease" = "red")) +
  theme_minimal()

```

##C)
###Density species
```{r}
#just selecting for algae species 
density_cols <- c("macro_stipe_density_",  "density_ptecal",
  "density_eisarb", "density_nerlue", "density_lamset",
  "density_lamstump", "density_macstump", "lamr",
  "macr", "macj", "nerj", "ptej",
  "lsetj", "eisj")

#SIMPER on density
comm_density_bf <- bar_for[, density_cols]

# Remove species with all zeros
comm_density_bf <- comm_density_bf[, colSums(comm_density_bf) > 0]
sim_density <- simper(comm_density, group, permutations = 0, trace = FALSE)
sim_density_summary <- summary(sim_density, ordered = TRUE, digits = 3)



group <- as.factor(bar_for$year)  # comparing 2024 vs 2025


#slightly adjusted to ecologically compare in simper (most of bar species are absent)
comm_density_adjusted <- comm_density_bf + 1e-6
sim_density <- simper(comm_density_adjusted, group, permutations = 0, trace = FALSE)
sim_density_summary <- summary(sim_density, ordered = TRUE, digits = 3)



# Clean & arrange SIMPER results
sim_density_df <- as.data.frame(sim_density_summary$`2024_2025`) %>%
  tibble::rownames_to_column("species") %>%
  filter(!is.na(average), average > 0) %>%
  arrange(desc(average)) %>%
  mutate(
    species = factor(species, levels = rev(species)), # order for plotting
    percent = 100 * average / sum(average),
    cumsum_percent = cumsum(percent)
  )

# Top 10 contributors
top_density <- sim_density_df %>% slice_head(n = 10)

# Plot with cumulative contribution line
ggplot(top_density, aes(x = species, y = percent)) +
  geom_bar(stat = "identity", fill = "firebrick", color = "black", width = 0.7) +
  geom_line(aes(y = cumsum_percent, group = 1), color = "black", linewidth = 1) +
  geom_point(aes(y = cumsum_percent), color = "black", size = 2, shape = 21, fill = "white") +
  coord_flip() +
  labs(
    title = "Top SIMPER Contributors (Density): BAR → FOR",
    x = NULL,
    y = "Contribution (%)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.y = element_blank(),   # remove horizontal grid lines
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "grey80", linetype = "dotted"),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )



#showing whether the average abundances increased or decreased from year one to year two 
sim_density_df_2 <- sim_density_df %>%
  mutate(
    change = ifelse(avb > ava, "Increase", "Decrease")
  )

# Top 10 contributors
top_density_2 <- sim_density_df_2 %>% slice_head(n = 10)

ggplot(top_density_2, aes(x = species, y = percent, fill = change)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(
    title = "Top SIMPER Contributors with Direction",
    x = "Species",
    y = "Contribution (%)"
  ) +
  scale_fill_manual(values = c("Increase" = "blue", "Decrease" = "red")) +
  theme_minimal()

```

#FIG 4: nMDS and envfit
##C)
```{r}
# Load packages
library(vegan)
library(ggplot2)
library(ggrepel)
library(dplyr)
library(grid)

#prepare community matrix
comm_cols <- c(
  "macro_stipe_density_", "density_purps_on_kelp", "density_ptecal",
  "density_eisarb", "density_nerlue", "density_lamset", "density_cancer_spp",
  "density_lamstump", "density_macstump",
  "purple_urchin_densitym2", "red_urchin_densitym2", "lamr",
  "macr", "macj", "nerj", "ptej",
  "lsetj", "eisj",
  grep("^cov_", names(bar_for), value = TRUE)
)

comm_matrix <- bar_for[, comm_cols]

# hellinger transformation to account for many zeros
comm_hellinger <- decostand(comm_matrix, method = "hellinger")

#environmental matrix
bar_for$pred_patch <- as.factor(bar_for$pred_patch)

env_vars <- c("risk_index", "relief_cm", "purple_urchin_densitym2","red_urchin_densitym2",
              "prop_purp_concealedm2", "prop_red_concealedm2",
              "tegula_densitym2", "pomaulax_densitym2", "zone")
env_matrix <- bar_for[, env_vars]

set.seed(123)

# nmds
nmds_model <- metaMDS(comm_hellinger, distance = "bray", k = 2, trymax = 100)

#envfit
env_matrix_numeric <- env_matrix %>% 
  dplyr::select(risk_index, relief_cm, purple_urchin_densitym2, red_urchin_densitym2,
         prop_purp_concealedm2, prop_red_concealedm2, tegula_densitym2, pomaulax_densitym2)

envfit_model <- envfit(nmds_model, env_matrix_numeric, permutations = 999)

# site scores
site_scores <- as.data.frame(scores(nmds_model, display = "sites"))
site_scores$pred_patch <- bar_for$pred_patch

#getting only env vectors that are significant 
vec_scores <- as.data.frame(scores(envfit_model, display = "vectors"))
vec_scores$pval <- envfit_model$vectors$pvals
vec_scores <- vec_scores %>% filter(pval < 0.05)
vec_scores$variable <- rownames(vec_scores)

# Scale by r values
vec_scores <- vec_scores %>%
  mutate(NMDS1 = NMDS1 * envfit_model$vectors$r[rownames(vec_scores)],
         NMDS2 = NMDS2 * envfit_model$vectors$r[rownames(vec_scores)])

# permanova
permanova_res <- adonis2(comm_hellinger ~ pred_patch, data = bar_for, permutations = 999)
R2 <- round(permanova_res$R2[1], 3)
pval <- permanova_res$`Pr(>F)`[1]

# Format p-value nicely for display
pval_label <- ifelse(pval < 0.001, "< 0.001", paste0("= ", round(pval, 3)))

# plot nmds with permanova and env vectors
ggplot() +
  geom_point(
    data = site_scores,
    aes(x = NMDS1, y = NMDS2, color = pred_patch),
    size = 3.5, alpha = 0.85
  ) +
  stat_ellipse(
    data = site_scores,
    aes(x = NMDS1, y = NMDS2, color = pred_patch),
    type = "t",
    linetype = "solid",
    size = 0.8,
    alpha = 0.15,
    show.legend = FALSE
  ) +
  #geom_segment(
   # data = vec_scores,
   # aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
    #arrow = arrow(length = unit(0.3, "cm"), type = "closed"),
    #color = "black",
    #size = 0.8

#  geom_text_repel(
    #data = vec_scores,
    #aes(x = NMDS1, y = NMDS2, label = variable),
    #color = "black",
    #size = 3.8,
   # fontface = "bold",
    #max.overlaps = Inf
  #) +
  #annotate("text",
           #x = min(site_scores$NMDS1), 
           #y = min(site_scores$NMDS2) - 0.1,
           #label = paste0("PERMANOVA: R² = ", R2, ", p ", pval_label),
          # hjust = 0, vjust = 1, size = 4.5, fontface = "italic") +
  theme_minimal(base_size = 14) +
  labs(
    x = "NMDS1",
    y = "NMDS2",
    color = "Patch Type"
  ) +
  scale_color_manual(values = c("BAR" = "red", "FOR" = "blue")) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(0.8, "cm"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    axis.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12)
  )



```

##B) 
```{r}
# Load packages
library(vegan)
library(ggplot2)
library(ggrepel)
library(dplyr)

# Prepare community matrix 
comm_cols <- c(
  "macro_stipe_density_", "density_purps_on_kelp", "density_ptecal",
  "density_eisarb", "density_nerlue", "density_lamset", "density_cancer_spp",
  "density_lamstump", "density_macstump",
  "purple_urchin_densitym2", "red_urchin_densitym2", "lamr",
  "macr", "macj", "nerj", "ptej",
  "lsetj", "eisj",
  grep("^cov_", names(incip_for), value = TRUE)
)

comm_matrix <- incip_for[, comm_cols]

# Hellinger transform to downweight zeros
comm_hellinger <- decostand(comm_matrix, method = "hellinger")

#Prepare environmental variables
incip_for$pred_patch <- as.factor(incip_for$pred_patch)

env_vars <- c("risk_index", "relief_cm", "purple_urchin_densitym2","red_urchin_densitym2", "prop_purp_concealedm2", "prop_red_concealedm2",
              "tegula_densitym2", "pomaulax_densitym2", "zone")
env_matrix <- incip_for[, env_vars]


set.seed(123)  # reproducibility

# nmds
nmds_model <- metaMDS(comm_hellinger, distance = "bray", k = 2, trymax = 100)

# envfit
env_matrix_numeric <- env_matrix %>% 
  dplyr::select(risk_index, relief_cm, purple_urchin_densitym2, red_urchin_densitym2,
         prop_purp_concealedm2, prop_red_concealedm2, tegula_densitym2, pomaulax_densitym2)

envfit_model <- envfit(nmds_model, env_matrix_numeric, permutations = 999)

# site scores
site_scores <- as.data.frame(scores(nmds_model, display = "sites"))
site_scores$pred_patch <- incip_for$pred_patch  # group labels

# significiant env vectors 
vec_scores <- as.data.frame(scores(envfit_model, display = "vectors"))
vec_scores$pval <- envfit_model$vectors$pvals
vec_scores <- vec_scores %>% filter(pval < 0.05)
vec_scores$variable <- rownames(vec_scores)

# Scale arrows by r (strength of correlation)
vec_scores <- vec_scores %>%
  mutate(NMDS1 = NMDS1 * envfit_model$vectors$r[rownames(vec_scores)],
         NMDS2 = NMDS2 * envfit_model$vectors$r[rownames(vec_scores)])

#PERMANOVA
permanova_res <- adonis2(comm_hellinger ~ pred_patch, data = incip_for, permutations = 999)
R2 <- round(permanova_res$R2[1], 3)
pval <- permanova_res$`Pr(>F)`[1]

# Format p-value nicely for display
pval_label <- ifelse(pval < 0.001, "< 0.001", paste0("= ", round(pval, 3)))

# plot
ggplot() +
  geom_point(
    data = site_scores,
    aes(x = NMDS1, y = NMDS2, color = pred_patch),
    size = 3.5, alpha = 0.85
  ) +
  stat_ellipse(
    data = site_scores,
    aes(x = NMDS1, y = NMDS2, color = pred_patch),
    type = "t",
    linetype = "solid",
    size = 0.8,
    alpha = 0.15,
    show.legend = FALSE
  ) +
  #geom_segment(
   # data = vec_scores,
   # aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
    #arrow = arrow(length = unit(0.3, "cm"), type = "closed"),
    #color = "black",
    #size = 0.8

#  geom_text_repel(
    #data = vec_scores,
    #aes(x = NMDS1, y = NMDS2, label = variable),
    #color = "black",
    #size = 3.8,
   # fontface = "bold",
    #max.overlaps = Inf
  #) +
  theme_minimal(base_size = 14) +
  labs(
    x = "NMDS1",
    y = "NMDS2",
    color = "Patch Type"
  ) +
  scale_color_manual(values = c("INCIP" = "forestgreen", "FOR" = "blue")) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.key = element_rect(fill = NA),
    legend.key.size = unit(0.8, "cm"),
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    axis.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12)
  )
```



